<!DOCTYPE html>
<html>
  <head>
    <title>Utilisation de Git</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1
        }
        
        .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      
     .box.happy .label {
  background-color: black;
}

 .box.happy {
  padding-top: 15px;
height: 1px;
border-bottom: solid 1px black;
}

._50pct {
	width : 50%;
}

.label {
  padding: 3px 5px 4px;
  color: white;
  font-weight: bold;
  text-transform: uppercase;
  white-space: nowrap;
  font-size: 0.75em;
  left: 10px;
  top: -25px;
  position: relative;
}

div.box p, div.box ul {
  position: relative;
  top: -20px;
}
      .gitCommands * {
font-size: small !important;
}

  .gitCommand pre {
margin-top: 0px;
}
      
      code {
background: #e7e8e2;
border-radius: 5px;
padding: 3px;
}

.small {
 font-size: x-small;
}
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Travail collaboratif efficace avec Git

---
## Objectifs

+ Comprendre les intérêts des gestionnaires de code
+ Effectuer des manipulations simples 
+ Découvrir une stratégie de gestion des projets

---

class: center, middle, inverse
## Introduction 

---
template: inverse

.left-column[
## Pourquoi un SCM ?
### - Pour soi
]
.right-column[

  - Il est utile de pouvoir retrouver les **différentes étapes** de son travail.    
  - Il est utile d'avoir **plusieurs versions** de son travail en même temps
]

---
.left-column[
## Pourquoi un SCM ?
  ### - Pour soi
  ### - Pour son équipe
]
.right-column[

  - Toute production - code ou autre - fait partie du patrimoine de son équipe et doit être **conservée** de manière pérenne (c.a.d avec des **pratiques connues**).    
]

---
.left-column[
  ## Pourquoi un SCM ?
  ### - Pour soi
  ### - Pour son équipe
  ### - Pour nos équipes
]
.right-column[
  - Il est **nécessaire** d'outiller et organiser le travail collaboratif 
]
---
## Pourquoi Git ?

- Il existe beaucoup de SCM : CVS, SVN, **Git**, Mercurial,... 
- En général chaque nouvelle génération d'outil rend la précédente obsolète

Git apporte beaucoup de souplesse :
  - Le travail **déconnecté**
  - La possibilité de travailler facilement sur **plusieurs versions** de l'application (les *branches*)
    - La version de production
    - La version en développement
  - La possibilité de **travailler à plusieurs** :
    - avec un serveur central
    - avec plusieurs serveurs centraux
    - directement entre plusieurs développeurs 

Git est 
  - **rapide**
  - **agnostique** : disponible sur tous les OS,
  - **social** : http://github.com 
  - **efficace** : gitflow
 


---
class: center, middle, inverse
## Remarques

---
## IDE Utilisé

  - Par défaut Git s'utilise avec l'invite de commande
  
  - Les principaux IDE (Eclipse, Netbeans, IntelliJ ...) masquent ces commandes en les intégrand à leur interface 

  - Les exercices proposés utilisent gratuit l'IDE PyCharm (Community Edition) <img src="./images/pyCharmLogo.png" width="24"/> disponible ici : https://www.jetbrains.com/pycharm/.

  - Toutefois, afin de permettre le passage vers d'autres IDE et l'appronfondissement de l'outil, les commandes sont indiquées en marge des exercices
  
<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git status
$ git add ...
```
]
</div>

 - L'onglet `Console` de PyCharm permet de voir les commandes effectuées de manière sous-jacente.

---
## Serveur Git

- Plusieurs serveurs Git en ligne et gratuits existent ([GitHub](https://github.com/), [BitBucket](https://bitbucket.org/),...)

- Il existe également des serveurs à installer localement ([GitLab C.E.](https://about.gitlab.com/)) 
- **Sourcesup**

  Renater propose gratuitement une forge destinée aux EPST, **[Sourcesup](http://sourcesup.renater.fr)** offrant les fonctionnalités suivantes :
 
   + Dépôts publics/privés (Authentification basée sur Sibboleth)
   + Git
   + Gestionnaire d'anomalies (Mantis BT) 
   + Wiki
   + Moteur d'intégration continue (Jenkins)
 
 Dans le cadre du *pôle Atmosphère* nous préconisons son utilisation pour les différents projets. C'est par exemple le cas de l'ensemble des projets du SEDOO (Observatoire Midi Pyrénées)
---
class: center, middle, inverse
## Quelques notions préliminaires
---
## Dépôt local et répertoire de travail

Pour chaque projet, Git utilise un répertoire (.git) dans lequel il va mettre l'ensemble des données/métadonnées permettant de retracer l'histoire du projet. 

C'est le **dépôt local** du projet.

Git va extraire de ce dépot une version du projet dans un répertoire afin de permettre l'édition des fichiers.

C'est le **répertoire de travail** du projet.

(En général le dépot local est un sous répertoire du projet)

---
## Instantané

Chaque fois qu'un projet est *validé*, Git stocke dans le dépôt local, une image de tous les fichers composants alors le projet. 

On parle d'**instantané**.

.center[<img src="./images/instantane.png" width="80%"/>]

---
## Échanges locaux
Avec Git, le cycle classique est le suivant : 

 1. On ajoute/supprime/modifie des fichiers dans l'espace de travail
 2. On groupe l'ensemble de ces modifications (on parle d'*indexation*)  
 3. On valide (*commit*) ces modifications dans le dépôt local en y associant un commentaire (exemple: correction de l'anomalie #145) 

.center[<img src="./images/echangesLocaux.png" width="50%"/>]


---
class: center, middle, inverse
## Manipulations locales
---
## Ajouter Git à un projet
Le projet peut déjà exister ou n'être qu'un répertoire vide.


+  Dans le menu `VCS`, sélectionnez `Enable Version Control Integration`

.center[<img src="./images/init1.png" width="60%"/>]


+  Dans la fenêtre popup, sélectionnez `Git` et cliquez sur `Ok`

.center[<img src="./images/init2.png" width="50%"/>]

+  A l'issue de la configuration, la barre de statut devrait afficher `Git:master`

.center[<img src="./images/init3.png" width="30%"/>]


---
## Ajouter Git à un projet

<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git init
```
]
</div>
---

## Connaitre les fichiers non validés

Il est utile de pouvoir facilement voir l'ensemble des fichiers ajoutés/supprimés/modifiés et non ajoutés au dépôt local.


+  Dans la barre de statut, faites apparaître le menu `Version Control` et cliquez dessus

.center[<img src="./images/status1.png" width="20%"/>] 

+  Cliquez sur `Local Changes` pour faire apparaître la liste des fichiers non validés

.center[<img src="./images/status2.png" width="50%"/>] 

---
## Connaitre les fichiers non validés

<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git status

# On branch master
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   fichier1.txt
#	modified:   fichier2.txt
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.idea/
no changes added to commit (use "git add" and/or "git commit -a")

```
]
</div>

- **Rappel :** L'onglet `Console` de PyCharm permet de voir les commandes effectuées de manière sous-jacente.

.center[<img src="./images/status3.png" width="50%"/>] 

---

## Ajouter des fichiers au dépot local (commit)

+ Dans le projet, créez deux fichiers, *fichier1.txt* et *fichier2.txt* avec comme contenu *Contenu du fichier X*

PyCharm vous propose par défaut que ces fichiers soient gérés par Git. Déclinez l'offre en cliquant sur `No`

.center[<img src="./images/add2.png" width="20%"/>]

+ Vous pouvez vérifier dans `Local Changes` que les deux fichiers apparaissent dans la section *Unversioned Files*

+ Sélectionnez les fichiers (dans l'arboresence du projet), Dans le menu contextuel cliquez sur `Git` puis sur `Add`.

.center[<img src="./images/add1.png" width="35%"/>]

---

## Ajouter des fichiers au dépot local 

Les fichiers sont désormais *indexés* et vont pouvoir être proposés au prochain *Commit*

+ Cliquez sur l'icône de commit

.center[<img src="./images/add3.png" width="35%"/>]

+ La fenêtre qui apparaît indique les fichiers qui vont faire partie du commit. Vous pouvez en désélectionner.

.center[<img src="./images/add4.png" width="25%"/>]

+ Indiquez un commentaire ainsi que le nom de l'auteur et cliquez sur `Commit`  

---

## Ajouter des fichiers au dépot local

<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git add monfichier
$ git commit
$ git commit -m "mon commentaire" (permet d indiquer directement un commentaire)
$ git commit -a -m "mon commentaire" (permet de passer la phase d indexation et prends en compte tous les fichiers)

```
]
</div>


---

## Ignorer des fichiers

Certains fichiers ne doivent pas être commités :

 + Fichier spécifiques à un IDE ou à un poste de développement
 + Fichiers générés (.java, .jar)
 + ...
 
PyCharm propose un mécanisme propriétaire pour ignorer les fichiers. Nous allons utiliser le **mécanisme standard de Git** qui repose sur un fichier nommé *.gitignore*

 + Créez un fichier *.gitignore* à la racine du projet
 
 + Indiquez comme contenu */.idea*.Cela signifie que tous les fichiers du répertoire *.idea* seront ignorés.
 
 + La liste *Unversioned Files* n'affiche plus les fichiers du répertoire *.idea*
 
 
.center[<img src="./images/ignore1.png" width="25%"/>]
 
---

## Ignorer des fichiers

### Remarques

+ Le fichier .gitignore est un fichier ordinaire : il doit être ajouté au dépôt et commité.
+ La syntaxe du fichier .gitignore est détaillée ici : http://git-scm.com/docs/gitignore
+ Des exemples de fichiers *.gitignore* adaptés à chaque language/framework sont disponibles : https://github.com/github/gitignore

---

## Supprimer un fichier

Lorsque que l'on supprime un fichier - via l'IDE par exemple - il faut répercuter cette suppression au niveau du dépôt local si celui-ci y était déjà présent. Cette opération est similaire à un commit.

 + Créez un fichier *fichier3.txt* avec comme contenu *Contenu du fichier 3*. Ajoutez ce fichier au dépot local
 
 + Supprimez le fichier dans l'arboresence du projet. 
 
 + Cliquez sur le bouton *Commit*
 
 .center[<img src="./images/rm1.png" width="10%"/>]
 
---

## Supprimer un fichier
 
 + Remarquez que cette fois-ci, la boite de dialogue indique que le commit va concerner une suppression
  
 .center[<img src="./images/rm2.png" width="35%"/>]

 + Commitez
 
<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git rm monfichier
$ git rm --cached monfichier 
(dans ce cas le fichier est supprimé du dépôt mais pas de l espace de travail)

```
]
</div>

---

## Renommer un fichier

Répercuter le changement de nom d'un fichier présent au dépôt est un action similaire à la suppression

 + Renommez le fichier *fichier2.txt* en *fichier2b.txt* (via le menu contextuel)
  
 .center[<img src="./images/renamming1.png" width="45%"/>]

 + L'onglet `Local Changes` indique que le changement est un changement de nom
  
 .center[<img src="./images/renamming2.png" width="31%"/>]

 + Cliquez sur le bouton *Commit*
 
 .center[<img src="./images/renamming3.png" width="7%"/>]

---


## Renommer un fichier
 
 + Remarquez que cette fois-ci, la boite de dialogue indique que le commit va concerner un changement de nom
  
 .center[<img src="./images/renamming4.png" width="35%"/>]

 + Commitez
 
<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
De manière sous-jacente, le renommage correspond à la succession des commandes :
$ git rm monfichier
$ git add monnouveaufichier
$ git commit

```
]
</div>

---
## Consulter l'historique

L'onglet `Log` permet de consulter l'historique du projet :

 + les différents *commits* (avec leur messages)
 + les différentes branches

.center[<img src="./images/logging1.png" width="100%"/>]

<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal

$ git log
$ git log --pretty=oneline
$ git log --pretty=short
$ git log --since="2 weeks ago"

```
]
</div>
---

## Consulter l'historique
 
Pour chaque *commit*, les différents fichiers concernés sont affichés sur le panneau de droite.

Dans le menu contextuel, `Show Diff with local` permet de voir les différences par rapport au répertoire de travail

.center[<img src="./images/logging2.png" width="35%"/>]

.center[<img src="./images/logging3.png" width="100%"/>]

---

## Consulter l'historique
 
Il est également possible de connaitre l'historique d'un fichier unique

.center[<img src="./images/logging4.png" width="35%"/>]

.center[<img src="./images/logging5.png" width="75%"/>]


---
## Consulter l'historique

<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal

$ git log -p --chemin/vers/le/fichier

```
]
</div>

---
## Ajouter des étiquettes (tag)

Une étiquette permet de donner un nom sur un instantanné afin d'être facilement identifiable par la suite.

Par exemple, cela permet d'associer un numéro de version à un état du projet. 

+ Dans la vue `Log`, sélectionnez le *commit* à *tagger* et faîtes apparaître le menu contextuel

+ Sélectionnez la commande `New Tag...`

.center[<img src="./images/tagging1.png" width="75%"/>]

---
## Ajouter des étiquettes (tag)

+ Indiquez le nom de l'étiquette et validez

.center[<img src="./images/tagging2.png" width="35%"/>]   

 + L'étiquette est visible dans la vue `Log`

.center[<img src="./images/tagging3.png" width="35%"/>]

 <div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal

$ git tag -a v1.0 (ajout de l etiquette)
$ git tag -a v1.0 -m 'mon commentaire'
$ git tag -d v1.0 (suppression de l etiquette)

```
]
</div>
---

## Remplacer un fichier par une version plus ancienne

La commande `git checkout` permet de naviguer entre les branches et les commits (cf. infra).

Elle peut toutefois être utilisée pour restaurer un fichier dans une version plus ancienne. Par exemple *fichier3.txt*.

 + Identifiez l'identifiant du commit contenant la version de *fichier3.txt* souhaitée via la vue `Log`. Dans notre cas **479b5c7**.
 
 .center[<img src="./images/restoring1.png" width="35%"/>]  
 
 + Ouvrir un terminal dans le répertoire racine du projet

---
## Remplacer un fichier par une version plus ancienne
 
 + Lancez la commande *git checkout **479b5c7** fichier3.txt*
 
 + Le fichier a été restauré et est présent dans l'espace de travail comme un nouveau fichier.
 
 .center[<img src="./images/restoring2.png" width="55%"/>] 
---
## Repartir d'un commit plus ancien

Il  peut être utile - mais **dangereux** - de repartir d'un *commit* plus ancien et de supprimer les *commits* survenus depuis.

 + Dans la fenêtre `Log`, sélectionnez le *commit* à partir duquel vous voulez repartir.
 
 + Dans le menu contextuel, sélectionnez la commande `Reset current branche to here...`
 
  .center[<img src="./images/reseting1.png" width="55%"/>] 

---
## Repartir d'un commit plus ancien
  
 + Dans la boite de dialogue choisissez l'option adaptée à votre besoin et validez en cliquant sur `Reset`.
 
  .center[<img src="./images/reseting2.png" width="45%"/>] 
 
<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git reset ...
```
]
</div>

Il est peut-être plus **prudent** de créer une branche à partir du *commit* identifié.

---
class: center, middle, inverse
## Les branches - Partie 1 : La théorie
---

## Pourquoi avoir besoin de branches ?

Il peut être nécessaire de travailler simultanément sur plusieurs versions du code:

 + version en production
 + version en développement
 + ...

Le concept de **branche** répond à ce besoin et les différents SCM le mettent en oeuvre. 

Toutefois, généralement, l'implémentation proposée fait que le concept est rarement utilisé.

*Exemple*: En SVN, les branches sont gérées sur le serveur et le temps de création des branches puis de bascule d'une branche à l'autre est rédhibitoire

** Avec Git, les branches sont très simples à gérer et le passage entre deux branches est quasi instantanné.**


---

## GitFlow 



- En 2010, Vincent Driessen publie un article intitulé *A successful Git branching model* (http://nvie.com/posts/a-successful-git-branching-model/) proposant une méthodologie efficace pour gérer les projets avec Git grâce aux branches.

- Cette méthodologie a été rapidement adoptée par beaucoup de grands acteurs du développement, notamment dans le cadre de méthodologie agile.

---

## GitFlow

.center[<img src="./images/gitflow1.png" width="53%"/>]

---

## GitFlow

### Principaux points

 - Branches pérennes
 
  - *master* : branche correspondant au code en production
  - *develop* : branche correspondant au code en développement
   
 - Branches transitoires
 
  - Feature : pour toute nouvelle fonctionalité ou correction de bug
  - Hotfix: correction de bug en production
  - Release : livraison

---
## GitFlow

### Remarque

- Une surcouche à Git en mode commande est également disponible mettant en oeuvre de manière explicite les principes de GitFlow. Toutefois, elle n'est pas indispensable.

.center[<img src="./images/gitflow2.png" width="53%"/>]

.small[.center[http://danielkummer.github.io/git-flow-cheatsheet/index.fr_FR.html]]

---
## Comment Git gère les branches ?

+ Chaque *commit* entraîne la création d'un instantané identifié par un numéro unique.

.center[<img src="./images/branching_manip1.png" width="53%"/>]

+ Avec Git, une branche est simplement un pointeur vers un instantanné

+ Un pointeur spécial, *HEAD*, indique la branche courante. 

.center[<img src="./images/branching_manip2.png" width="53%"/>]

---

## Comment Git gère les branches ?

+ Créer une nouvelle branche revient donc à ajouter un nouveau pointeur sur l'instantanné courant.

.center[<img src="./images/branching_manip3.png" width="33%"/>]

+ Changer de branche consiste à basculer vers l'instantanné pointé par la branche et à mettre à jour le pointeur *HEAD*.

.center[<img src="./images/branching_manip4.png" width="33%"/>]

---

## Comment Git gère les branches ?

+ Lors des *commits* suivants seul le pointeur de la branche actuelle va se déplacer.

.center[<img src="./images/branching_manip5.png" width="53%"/>]

---

## Les fusions

 + Deux cas se présentent en général 
 
   1. La branche qui va recevoir la fusion est un ancêtre de la branche à fusionner
   2. La branche qui va recevoir la fusion n'est pas un ancêtre de la branche à fusionner  

---

## Les fusions

### Cas 1 : La branche qui va recevoir la fusion est un ancêtre de la branche à fusionner
 
Ce cas est très simple, la fusion revient simplement à déplacer le curseur de la branche recevante sur l'instantanné pointé par la branche à fusionner.
.center[ <img src="./images/branching_manip5b.png" width="33%"/>]
.small[.center[**Avant fusion**]]
.center[<img src="./images/branching_manip6.png" width="33%"/>]
.small[.center[**Après fusion**]]

---

## Les fusions

### Cas 2 : La branche qui va recevoir la fusion n'est pas un ancêtre de la branche à fusionner
 
Ce cas est potentiellement compliqué car certains fichiers ont pu être modifiés dans les deux branches, il va falloir fusionner ces fichiers via un nouvel instantanné.
.center[ <img src="./images/branching_manip7.png" width="27%"/>]
.small[.center[**Avant fusion**]]
.center[<img src="./images/branching_manip8.png" width="33%"/>]
.small[.center[**Après fusion**]]

---
class: center, middle, inverse
## Les branches - Partie 2 : La pratique


---
## Créer une branche

La branche courante est indiquée à droite de la barre de statut.

.center[<img src="./images/practicalBranching1.png" width="33%"/>]

Par défaut, la 1ère branche s'appelle *master*.


Pour créer une nouvelle branche et basculer dessus :

+ Cliquez sur la branche actuelle afin de faire apparaitre le menu déroulant et sélectionnez l'action `New Branch`

.center[<img src="./images/practicalBranching2.png" width="33%"/>]

---
## Créer une branche

+ Dans la boite de dialogue, indiquez le nom de la nouvelle branche : *develop*
 
.center[<img src="./images/practicalBranching3.png" width="33%"/>] 

+ La vue `Log` affiche les deux branches au niveau du dernier *commit*  

.center[<img src="./images/practicalBranching4.png" width="33%"/>] 

---
## Créer une branche

La barre de statut indique désormais *develop* comme branche actuelle.

.center[<img src="./images/practicalBranching5.png" width="33%"/>]

Créez de la même manière une branche nommée *feature_MaFonction*.

<div class="100pct" >
<div class="happy box">
.label[Mode commande]
</div>
 .gitCommand[
```terminal
$ git checkout -b mabranche (si la branche n existe pas elle est créée, 
sinon il s agit d une simple bascule)
```
]
</div>

---
## Basculer d'une branche à l'autre

+ Le menu déroulant des branches indique les différentes branches présentes

+ Pour basculer d'une branche à l'autre, il suffit de chosir la branche cible dans le menu et de cliquer sur `Checkout`

.center[<img src="./images/practicalBranching6.png" width="33%"/>]

La bascule est très rapide car totalement locale.

---
## Basculer d'une branche à l'autre

Stash !!!

Le fichier fichier 3.txt a suivi

---
class: center, middle, inverse
## Conclusion 
---
## Pour aller plus loin : ** Pro Git** (par Scott Chacon)

 - Ouvrage de référence 
 - Disponible gratuitement en français : https://git-scm.com/book/fr/v2 (différents formats: pdf, html, epub...)
---
class: center, middle, inverse
## Merci.


    </textarea>
   <!--  <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"> -->
   <script src="./offline/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>